import numpy as np

class Coder:
    """
    Mappings between human-readable tokens and activity patterns.
    Tokens should be strings and patterns should be numpy arrays.
    patterns must be convertable to hashable type for storage in dicts.
    """

    def __init__(self, make_pattern, hash_pattern):
        """
        Set up a coder with a supplied pattern maker function.
        Patterns will be generated by calling make_pattern.
        Patterns will be hashed by calling hash_pattern.
        """
        self.make_pattern = make_pattern
        self._hash = hash_pattern
        self.encodings = {} # maps tokens to patterns
        self.decodings = {} # maps patterns to tokens
        
    def list_tokens(self):
        """Return a list of all tokens encoded so far."""
        return self.encodings.keys()

    def encode(self, token):
        """
        Return the pattern encoding a token.
        Uses make_pattern() if token was not already encoded.
        """
        # Encode if not already encoded
        if token not in self.encodings:
            pattern = self.make_pattern()
            self.encodings[token] = pattern
            self.decodings[self._hash(pattern)] = token
        return self.encodings[token]
        
    def decode(self, pattern):
        """
        Decode a pattern into a token.
        If no token has been encoded as the pattern, the default is "?"
        """
        return self.decodings.get(self._hash(pattern), "?")


if __name__ == "__main__":
    
    N = 8
    PAD = 0.9
    
    from activator import *
    # act = tanh_activator(PAD, N)
    act = logistic_activator(PAD, N)

    c = Coder(act.make_pattern, act.hash_pattern)
    v = c.encode("TEST")
    print(v.T)
    print(c.decode(v))
    print(c.encode("TEST").T)
    print(c.decode(act.make_pattern()))
